<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#4caf50" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icons/icon-192x192.png" />
  <title>Medic Portal - Record</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
  <style>
    .animate__animated { animation-duration: 0.8s; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #f1f1f1; }
    ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }
    #actions button, #actions input { min-width: 150px; }
    .transcription-container { display: flex; flex-direction: column; }
    #audioPlayback { display: flex; align-items: center; gap: 10px; flex: 1; }
    #recordingStatus { display: flex; justify-content: center; align-items: center; }
    header { position: sticky; top: 0; z-index: 1000; width: 100%; background-color: white; }
    header .header-content { max-width: 3xl; margin-left: auto; margin-right: auto; }
    #loader-container {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex; justify-content: center; align-items: center;
      z-index: 1000; display: none;
    }
    #loader-container img {
      width: 80px; height: 80px; animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #ai-response { white-space: pre-wrap; overflow-y: auto; max-height: 400px; }
    textarea::placeholder { opacity: 0.4; }
    #backButton { cursor: pointer; }
    body {
      background-color: #f5f5f5;
      font-family: 'Inter', sans-serif;
      overscroll-behavior: contain;
      touch-action: pan-y;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      min-height: 100vh;
      height: auto;
      overflow-y: auto;
    }
    /* Document container styles */
    .document-container {
      background-color: #fff;
      padding: 20px;
      border: 1px solid #ddd;
      max-width: 800px;
      margin: 40px auto;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      box-sizing: border-box;
      overflow: hidden;
      font-family: 'Lato', sans-serif;
    }
    .document-container h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 1rem;
      color: #333;
    }
    .document-container h2 {
      color: #555;
      border-bottom: 2px solid #ddd;
      padding-bottom: 5px;
      margin-top: 20px;
      font-size: 0.8rem;
    }
    .document-container label {
      font-size: 0.9rem;
      color: #555;
      font-weight: bold;
      display: block;
      margin-bottom: 5px;
    }
    .document-container input[type="text"],
    .document-container input[type="email"],
    .document-container textarea,
    .document-container select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
      margin-bottom: 15px;
      box-sizing: border-box;
      resize: vertical;
    }
    /* Option buttons and edit input styles */
    .option-buttons {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
    }
    .option-buttons button {
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }
    .option-buttons button.save { background-color: #4caf50; color: white; }
    .option-buttons button.email { background-color: #2196f3; color: white; }
    .option-buttons button.edit { background-color: #ff9800; color: white; }
    .email-input, .edit-input {
      display: none;
      margin-top: 10px;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    .email-input input, .edit-input textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    /* Edit Input Container for Update Options */
    #editInputContainer {
      max-width: 800px;
      margin: 20px auto;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
    }
    #editInputContainer .flex { display: flex; align-items: center; gap: 10px; }
    #editInputContainer textarea {
      width: 100%;
      height: 80px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 8px;
    }
    #editInputContainer button {
      background-color: #e0e0e0;
      border: none;
      padding: 8px;
      border-radius: 50%;
      cursor: pointer;
    }
    #applyEditsButton {
      background-color: #ff9800;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      margin-top: 10px;
      cursor: pointer;
    }
    #applyEditsButton:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    /* Paper printing animation styles */
    .paper-printing-container {
      overflow: hidden;
    }
    .paper-printing-animation {
      display: block;
      overflow: hidden;
      white-space: nowrap;
      border-right: 0.05em solid black;
      animation: printing 2s steps(40, end) forwards, blink-caret 0.75s step-end infinite alternate;
    }
    @keyframes printing {
      from { width: 0 }
      to { width: 100% }
    }
    @keyframes blink-caret {
      from, to { border-color: transparent }
      50% { border-color: black; }
    }
    .line-printing-container { overflow: hidden; }
    .line-printing-animation {
      clip-path: inset(100% 0 0 0);
      animation: line-reveal 1s linear forwards;
      animation-delay: calc(0.1s * var(--line-index));
      display: block;
    }
    @keyframes line-reveal {
      to { clip-path: inset(0 0 0 0); }
    }
    /* Hide waiting audio element */
    #waitingAudio { display: none; }
  </style>
</head>
<body class="bg-gray-50 font-sans">
  <!-- Loader with spinner animation -->
  <div id="loader-container">
    <img src="https://daisy.aitekchat.com/assets/images/loader.gif" alt="Loading..." />
  </div>

  <!-- Waiting audio -->
  <audio id="waitingAudio" loop>
    <source src="https://daisy.aitekchat.com/assets/audio/waiting.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <header class="header">
    <div class="header-content flex items-center justify-between px-4 py-3 md:px-6">
      <div class="flex items-center">
        <h1 class="header-title">Generated Scribe</h1>
      </div>
      <a href="index.html" class="header-close">
        <i class="fas fa-times"></i>
      </a>
    </div>
  </header>

  <div class="container">
    <div class="header-info">
      <p><strong>Title:</strong> <input type="text" id="title" placeholder="Enter Title"></p>
      <p><strong>Patient Name:</strong> <input type="text" id="patientName" placeholder="Patient Name"></p>
      <p><strong>Assigned Medical Practitioner:</strong> <input type="text" id="assignedMedicalPractitioner" placeholder="Assigned Medical Practitioner"></p>
      <p><strong>Conducted on:</strong> <input type="text" id="conductedOn" placeholder="Conducted on"></p>
      <p><strong>Location:</strong> <input type="text" id="location" placeholder="Location"></p>
    </div>

    <div class="section">
      <h2>Subjective Data</h2>
      <div class="grid">
        <div>
          <label for="age">Age:</label>
          <input type="text" id="age" placeholder="Age">
        </div>
        <div>
          <label for="race">Nationality:</label>
          <input type="text" id="race" placeholder="Nationality">
        </div>
        <div>
          <label for="gender">Gender:</label>
          <input type="text" id="gender" placeholder="Gender">
        </div>
      </div>
      <div>
        <label for="chiefComplaint">Chief Complaint:</label>
        <textarea id="chiefComplaint" placeholder="Patient presents with a complaint of..."></textarea>
      </div>
      <div>
        <label for="historyOfIllness">History of Present Illness:</label>
        <textarea id="historyOfIllness" placeholder="Patient's symptoms started..."></textarea>
      </div>
      <div>
        <label for="pastMedicalHistory">Past Medical History:</label>
        <textarea id="pastMedicalHistory" placeholder="Allergies: None. Current medication: None. Injuries: None. Hospitalizations: None. Surgeries: None"></textarea>
      </div>
      <div>
        <label for="familyHistory">Family History:</label>
        <textarea id="familyHistory" placeholder="None relevant to the current condition"></textarea>
      </div>
      <div>
        <label for="socialHistory">Social History:</label>
        <textarea id="socialHistory" placeholder="Patient lives with..."></textarea>
      </div>
      <div>
        <label for="reviewOfSystems">Review of Systems:</label>
        <textarea id="reviewOfSystems" placeholder="The patient is experiencing..."></textarea>
      </div>
    </div>

    <div class="section">
      <h2>Objective Data</h2>
      <div class="grid grid-4">
        <div>
          <label for="height">Height (in):</label>
          <input type="text" id="height" placeholder="Height (in)">
        </div>
        <div>
          <label for="weight">Weight (lbs):</label>
          <input type="text" id="weight" placeholder="Weight (lbs)">
        </div>
        <div>
          <label for="bmi">BMI:</label>
          <input type="text" id="bmi" placeholder="BMI">
        </div>
        <div>
          <label for="temperature">Temperature:</label>
          <input type="text" id="temperature" placeholder="Temperature">
        </div>
        <div>
          <label for="bloodPressure">Blood Pressure (BP):</label>
          <input type="text" id="bloodPressure" placeholder="Blood Pressure (BP)">
        </div>
      </div>
      <div>
        <label for="generalAppearance">General Appearance:</label>
        <textarea id="generalAppearance" placeholder="Patient appears..."></textarea>
      </div>
      <div>
        <label for="eent">EENT (Eyes, Ears, Nose, Throat):</label>
        <textarea id="eent" placeholder="The eyes, ears, nose, and throat are..."></textarea>
      </div>
      <div>
        <label for="cardiovascular">Cardiovascular:</label>
        <textarea id="cardiovascular" placeholder="The heart sounds are..."></textarea>
      </div>
      <div>
        <label for="respiratory">Respiratory:</label>
        <textarea id="respiratory" placeholder="The lung sounds are..."></textarea>
      </div>
      <div>
        <label for="integument">Integument/Lymphatic Inspection:</label>
        <textarea id="integument" placeholder="The skin is..."></textarea>
      </div>
      <div>
        <label for="labResults">Laboratory Results:</label>
        <textarea id="labResults" placeholder="The results of the blood tests indicate..."></textarea>
      </div>
    </div>

    <div class="section">
      <h2>Assessment</h2>
      <div>
        <label for="generalObservations">General Observations:</label>
        <textarea id="generalObservations" placeholder="Based on the patient's symptoms and physical examination..."></textarea>
      </div>
      <div>
        <label for="differentialDiagnosis">Differential Diagnosis:</label>
        <textarea id="differentialDiagnosis" placeholder="The likely differential diagnosis includes..."></textarea>
      </div>
    </div>

    <div class="section">
      <h2>Plan</h2>
      <div>
        <label for="treatmentPlan">Treatment Plan:</label>
        <textarea id="treatmentPlan" placeholder="The patient will be treated with..."></textarea>
      </div>
      <div>
        <label for="followUp">Follow-up:</label>
        <textarea id="followUp" placeholder="The patient will follow up in..."></textarea>
      </div>
      <div>
        <label for="education">Education:</label>
        <textarea id="education" placeholder="The patient and family will be educated about..."></textarea>
      </div>
    </div>

    <div class="section">
      <h2>Completion</h2>
      <div class="grid">
        <div class="sig-container" title="Name & Signature of Attending Medical Practitioner">
          <label>Name & Signature of Attending Medical Practitioner:</label>
          <div class="signature-upload">
            <input type="file" id="signatureUpload" accept="image/png">
            <img id="signatureImage" style="display: none;" alt="Signature">
            <input type="text" id="printedName" placeholder="Enter Printed Name" title="Enter Printed Name">
          </div>
        </div>
        <div>
          <label for="date">Date:</label>
          <input type="text" id="date" placeholder="Date">
        </div>
      </div>
      <!-- Export Options Section -->
      <div class="export-buttons option-section">
        <button id="saveButton">Save</button>
        <button id="emailButton">Send</button>
        <button id="editButton">Edit</button>
      </div>
      <div id="scribeHistory">
        <h2>Scribe History</h2>
        <ul></ul>
      </div>
    </div>

    <!-- Email Input Container (hidden by default) -->
    <div class="section email-input" id="emailInputContainer" style="display: none;">
      <label for="email">Email Address:</label>
      <input type="email" id="email" placeholder="Enter email address">
      <div class="export-buttons">
        <button id="sendViaEmailButton">Send via Email</button>
      </div>
    </div>

    <!-- Edit Input Container (hidden by default) -->
    <div class="section edit-input" id="editInputContainer" style="display: none;">
      <div class="flex">
        <textarea id="editInstructions" placeholder="Enter your edits or new instructions here..." class="w-full h-20 border border-gray-300 rounded p-2"></textarea>
        <button id="recordEditButton" class="bg-gray-200 p-2 rounded-full">
          <span class="material-icons">mic</span>
        </button>
      </div>
      <div class="export-buttons">
        <button id="applyEditsButton" class="bg-orange-500 text-white py-2 px-4 rounded" disabled>Update</button>
      </div>
    </div>
  </div>

  <!-- Generated Document will appear below the page -->
  <div id="documentContainer" class="max-w-3xl mx-auto mb-20 animate__animated"></div>

  <!-- External Scripts -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="userdata.js"></script>
  <script src="pwa.js"></script>
  <script src="disable-zoom.js"></script>

  <script>
    // API Keys and Global Variables
    const DEEPGRAM_API_KEY = "66254ea0e11de8ae233df109477e394bb3fbf1b2";
    const GEMINI_API_KEY = "AIzaSyBPCoWjTruuBVVqQU2mRFgMT1ooLyp2yNM";

    let mediaRecorder, audioChunks = [], audioBlob, isPaused = false;
    let editMediaRecorder, editAudioChunks = [];

    // UI Elements
    const startRecordingButton = document.getElementById('startRecording');
    const pauseRecordingButton = document.getElementById('pauseRecording');
    const stopRecordingButton = document.getElementById('stopRecording');
    const recordingStatus = document.getElementById('recordingStatus');
    const audioPlayback = document.getElementById('audioPlayback');
    const transcriptionText = document.getElementById('transcriptionText');
    const createScribeButton = document.getElementById('createScribeButton');
    const patientNameLabel = document.getElementById('patientNameLabel');
    const templateLabel = document.getElementById('templateLabel');
    const aiResponseDiv = document.getElementById('ai-response');
    const loaderContainer = document.getElementById('loader-container');
    const waitingAudio = document.getElementById('waitingAudio');
    const saveToFirestoreButton = document.getElementById('saveToFirestore');
    const successMessage = document.getElementById('successMessage');
    const backButton = document.getElementById('backButton');
    const documentContainer = document.getElementById('documentContainer');
    const editInputContainer = document.getElementById('editInputContainer');
    const emailInputContainer = document.getElementById('emailInputContainer');

    backButton.addEventListener('click', () => window.history.back());

    // Firebase configuration and initialization
    const firebaseConfig = {
      apiKey: "AIzaSyBe9a58zaQCrBSGeWwcIVa_PnZABoH6zV4",
      authDomain: "tudds-ccd0wn.firebaseapp.com",
      databaseURL: "https://tudds-ccd0wn-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "tudds-ccd0wn",
      storageBucket: "tudds-ccd0wn.appspot.com",
      messagingSenderId: "786974954352",
      appId: "1:786974954352:web:696d4fce818f14659bb5b5",
      measurementId: "G-CEQL4E8CW3"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    // Recording Functions
    startRecordingButton.addEventListener('click', startRecording);
    pauseRecordingButton.addEventListener('click', pauseRecording);
    stopRecordingButton.addEventListener('click', stopRecording);
    createScribeButton.addEventListener('click', createScribe);
    saveToFirestoreButton.addEventListener('click', saveToFirestore);

    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        audioChunks = [];
        audioPlayback.style.display = 'none';
        audioPlayback.src = '';
        transcriptionText.value = '';
        aiResponseDiv.textContent = 'Daisy Response will appear here...';
        aiResponseDiv.classList.add('hidden');
        saveToFirestoreButton.classList.add('hidden');

        mediaRecorder.ondataavailable = (event) => audioChunks.push(event.data);
        mediaRecorder.onstop = async () => {
          audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          audioPlayback.src = audioUrl;
          audioPlayback.style.display = 'flex';
          console.log('Recording stopped. Audio blob ready.');
          await submitForTranscription();
        };

        mediaRecorder.start();
        recordingStatus.textContent = 'Recording...';
        stopRecordingButton.classList.remove('hidden');
        pauseRecordingButton.classList.remove('hidden');
        startRecordingButton.classList.add('hidden');
      } catch (error) {
        console.error('Error accessing microphone:', error);
        alert('Microphone access is required.');
      }
    }

    function pauseRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.pause();
        isPaused = true;
        recordingStatus.textContent = 'Recording Paused';
        pauseRecordingButton.textContent = 'Resume Recording';
        pauseRecordingButton.classList.replace('bg-yellow-500', 'bg-green-500');
      } else if (mediaRecorder && mediaRecorder.state === 'paused') {
        mediaRecorder.resume();
        isPaused = false;
        recordingStatus.textContent = 'Recording...';
        pauseRecordingButton.textContent = 'Pause Recording';
        pauseRecordingButton.classList.replace('bg-green-500', 'bg-yellow-500');
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
        recordingStatus.textContent = 'Recording stopped. Processing...';
        stopRecordingButton.classList.add('hidden');
        pauseRecordingButton.classList.add('hidden');
        startRecordingButton.classList.remove('hidden');
      }
    }

    async function submitForTranscription() {
      if (!audioBlob) {
        alert('No recording available.');
        return;
      }
      const patientName = document.getElementById('patientName').value.trim();
      const templateType = document.getElementById('templateSelect').value;
      recordingStatus.textContent = 'Transcribing...';

      const formData = new FormData();
      formData.append('audio', audioBlob, 'recording.webm');

      try {
        const response = await fetch('https://api.deepgram.com/v1/listen?utterances=true&diarize=true&language=multi&model=nova-3&smart_format=true', {
          method: 'POST',
          headers: {
            'Authorization': `Token ${DEEPGRAM_API_KEY}`
          },
          body: formData
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const data = await response.json();
        if (!data.results || !data.results.channels || data.results.channels.length === 0) {
          throw new Error('Invalid response from Deepgram API');
        }
        const transcript = data.results.channels[0].alternatives[0].transcript;
        transcriptionText.value = transcript;
        patientNameLabel.textContent = `Patient Name: ${patientName || 'N/A'}`;
        templateLabel.textContent = `Template: ${templateType || 'N/A'}`;
        recordingStatus.textContent = 'Transcription complete. Editable below.';
      } catch (error) {
        console.error('Transcription error:', error);
        recordingStatus.textContent = 'Error during transcription.';
        alert(`Transcription failed: ${error.message}`);
      }
    }

    // Two-step createScribe function: first get raw output, then build new prompt to convert to HTML.
    async function createScribe() {
      const scribeText = transcriptionText.value;
      if (scribeText.trim() === "") {
        alert("Transcription text is empty.");
        return;
      }

      loaderContainer.style.display = 'flex';
      waitingAudio.play();

      try {
        // First call: get raw output from Gemini
        const rawResponse = await fetchFromGeminiAPI(scribeText);
        console.log("Raw AI Response:", rawResponse);

        // Build a new prompt using the raw output
        const newPrompt = `You are Daisy, a very intelligent medical scribe assistant. Convert the following text into a full HTML page that exactly follows the sample HTML template provided at https://app.medicalscribe.site/scribe.html. For any missing or unclear sections, fill in with "Not Clear" or "No Data Given" as needed. Do NOT include any JSON or markdown formattingâ€”return a complete HTML document including DOCTYPE, head, and body.
        
Here is the text to convert:
${rawResponse}`;

        // Second call: get the final HTML output
        const htmlResponse = await fetchFromGeminiAPI(newPrompt);
        console.log("Final HTML Response:", htmlResponse);

        let cleanResponse = htmlResponse.replace(/\`\`\`(html)?/g, '').replace(/\`\`\`/g, '').trim();
        aiResponseDiv.textContent = "Full HTML generated successfully.";
        aiResponseDiv.classList.remove('hidden');

        const parser = new DOMParser();
        const aiDoc = parser.parseFromString(cleanResponse, "text/html");
        const bodyContent = aiDoc.body.innerHTML;

        // Optionally apply line-by-line animation
        let animatedBodyContent = '';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = bodyContent;
        let lineIndex = 1;
        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            animatedBodyContent += `<div class="line-printing-container"><div class="line-printing-animation" style="--line-index: ${lineIndex};">${node.outerHTML}</div></div>`;
            lineIndex++;
          } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
            animatedBodyContent += `<div class="line-printing-container"><div class="line-printing-animation" style="--line-index: ${lineIndex};"><p>${node.textContent.trim()}</p></div></div>`;
            lineIndex++;
          }
        });

        document.getElementById('documentContainer').innerHTML = `<div class="animate__fadeIn">${animatedBodyContent}</div>`;
        attachOptionEvents();
        scrollToDocument();

      } catch (error) {
        console.error("Error in AI processing:", error);
        alert("Failed to process the transcription.");
      } finally {
        loaderContainer.style.display = 'none';
        waitingAudio.pause();
      }
    }

    async function fetchFromGeminiAPI(input) {
      const geminiApiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-thinking-exp-01-21:generateContent?key=${GEMINI_API_KEY}`;
      const systemPrompt = `You are Daisy, a very intelligent medical scribe assistant. Generate a full HTML page that follows the sample HTML here https://app.medicalscribe.site/scribe.html.
For any missing or unclear section, fill in with "Not Clear" or "No Data Given" as appropriate.
Do NOT return JSON. Return the full HTML including DOCTYPE, head, and body.
The HTML should be fully self-contained and styled as per the sample template.`;
      const requestBody = {
        "contents": [
          {"role": "user", "parts": [{ "text": systemPrompt + "\n\n" + input}]}
        ],
        "generationConfig": {
          "temperature": 0.7,
          "topK": 64,
          "topP": 0.95,
          "maxOutputTokens": 65536,
          "responseMimeType": "text/plain"
        }
      };
      const response = await fetch(geminiApiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      if (data.candidates && data.candidates.length > 0 &&
          data.candidates[0].content && data.candidates[0].content.parts &&
          data.candidates[0].content.parts.length > 0 && data.candidates[0].content.parts[0].text) {
        const aiResponseContent = data.candidates[0].content.parts[0].text;
        console.log("Raw Gemini AI Response:", aiResponseContent);
        return aiResponseContent;
      } else {
        console.error("Unexpected Gemini API response format:", data);
        throw new Error("Unexpected response format from Gemini API");
      }
    }

    function attachOptionEvents() {
      const saveBtn = document.getElementById('saveDocumentButton');
      const emailBtn = document.getElementById('emailDocumentButton');
      const editBtn = document.getElementById('editDocumentButton');

      if (saveBtn) saveBtn.addEventListener('click', saveDocument);
      if (emailBtn) emailBtn.addEventListener('click', toggleEmailInput);
      if (editBtn) editBtn.addEventListener('click', toggleEditInput);

      const sendEmailBtn = document.getElementById('sendEmailButton');
      if (sendEmailBtn) sendEmailBtn.addEventListener('click', sendEmail);
      const applyEditsBtn = document.getElementById('applyEditsButton');
      if (applyEditsBtn) applyEditsBtn.addEventListener('click', applyEdits);

      document.getElementById('recordEditButton').addEventListener('click', function() {
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
          editMediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          editAudioChunks = [];
          editMediaRecorder.ondataavailable = (event) => editAudioChunks.push(event.data);
          editMediaRecorder.onstop = async () => {
            let editBlob = new Blob(editAudioChunks, { type: 'audio/webm' });
            let formData = new FormData();
            formData.append('audio', editBlob, 'editRecording.webm');
            try {
              const response = await fetch('https://api.deepgram.com/v1/listen?language=en&model=nova-3', {
                method: 'POST',
                headers: { 'Authorization': `Token ${DEEPGRAM_API_KEY}` },
                body: formData
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();
              if (!data.results || !data.results.channels || data.results.channels.length === 0) {
                throw new Error('Invalid response from Deepgram API');
              }
              const editTranscript = data.results.channels[0].alternatives[0].transcript;
              let editTextarea = document.getElementById('editInstructions');
              editTextarea.value += editTranscript;
              document.getElementById('applyEditsButton').disabled = (editTextarea.value.trim() === "");
            } catch (error) {
              console.error('Edit transcription error:', error);
              alert("Failed to transcribe edit instructions: " + error.message);
            }
          };
          editMediaRecorder.start();
          document.getElementById('recordEditButton').innerHTML = '<span class="material-icons">stop</span>';
          document.getElementById('recordEditButton').addEventListener('click', stopEditRecording, { once: true });
        });
      });
    }

    async function stopEditRecording() {
      if (editMediaRecorder && editMediaRecorder.state !== 'inactive') {
        editMediaRecorder.stop();
        document.getElementById('recordEditButton').innerHTML = '<span class="material-icons">mic</span>';
      }
    }

    async function saveDocument() {
      const scribeData = {
        title: document.getElementById('docTitle').value || "No Data Given",
        patientName: document.getElementById('docPatientName').value || "No Data Given",
        assignedMedicalPractitioner: document.getElementById('docAssignedPractitioner').value || "No Data Given",
        conductedOn: document.getElementById('docConductedOn').value || "No Data Given",
        location: document.getElementById('docLocation').value || "No Data Given",
        age: document.getElementById('docAge').value || "No Data Given",
        race: document.getElementById('docRace').value || "No Data Given",
        gender: document.getElementById('docGender').value || "No Data Given",
        chiefComplaint: document.getElementById('docChiefComplaint').value || "No Data Given",
        historyOfIllness: document.getElementById('docHistoryOfIllness').value || "No Data Given",
        pastMedicalHistory: document.getElementById('docPastMedicalHistory').value || "No Data Given",
        familyHistory: document.getElementById('docFamilyHistory').value || "No Data Given",
        socialHistory: document.getElementById('docSocialHistory').value || "No Data Given",
        reviewOfSystems: document.getElementById('docReviewOfSystems').value || "No Data Given",
        height: document.getElementById('docHeight').value || "No Data Given",
        weight: document.getElementById('docWeight').value || "No Data Given",
        bmi: document.getElementById('docBMI').value || "No Data Given",
        temperature: document.getElementById('docTemperature').value || "No Data Given",
        bloodPressure: document.getElementById('docBloodPressure').value || "No Data Given",
        generalAppearance: document.getElementById('docGeneralAppearance').value || "No Data Given",
        eent: document.getElementById('docEENT').value || "No Data Given",
        cardiovascular: document.getElementById('docCardiovascular').value || "No Data Given",
        respiratory: document.getElementById('docRespiratory').value || "No Data Given",
        integument: document.getElementById('docIntegument').value || "No Data Given",
        labResults: document.getElementById('docLabResults').value || "No Data Given",
        generalObservations: document.getElementById('docGeneralObservations').value || "No Data Given",
        differentialDiagnosis: document.getElementById('docDifferentialDiagnosis').value || "No Data Given",
        treatmentPlan: document.getElementById('docTreatmentPlan').value || "No Data Given",
        followUp: document.getElementById('docFollowUp').value || "No Data Given",
        education: document.getElementById('docEducation').value || "No Data Given",
        printedName: document.getElementById('docPrintedName').value || "No Data Given",
        date: document.getElementById('docDate').value || new Date().toLocaleDateString(),
        created_at: firebase.firestore.FieldValue.serverTimestamp()
      };

      try {
        const docRef = await db.collection('scribe_documents').add(scribeData);
        console.log('Document written with ID:', docRef.id);
        alert('Document saved successfully.');
      } catch (error) {
        console.error('Error saving document:', error);
        alert('Failed to save document to Firestore.');
      }
    }

    function toggleEmailInput() {
      const container = document.getElementById('emailInputContainer');
      container.style.display = (container.style.display === 'block') ? 'none' : 'block';
    }

    function sendEmail() {
      const recipient = document.getElementById('recipientEmail').value;
      if (!recipient) {
        alert("Please enter an email address.");
        return;
      }
      const body = encodeURIComponent(documentContainer.innerText);
      window.location.href = `mailto:${recipient}?subject=Generated%20Scribe%20Document&body=${body}`;
    }

    function toggleEditInput() {
      const container = document.getElementById('editInputContainer');
      container.style.display = (container.style.display === 'block') ? 'none' : 'block';
    }

    async function applyEdits() {
      const instructions = document.getElementById('editInstructions').value;
      if (!instructions) {
        alert("Please enter your edit instructions.");
        return;
      }
      loaderContainer.style.display = 'flex';
      waitingAudio.play();
      try {
        const newPrompt = transcriptionText.value + "\nEdits: " + instructions;
        const response = await fetchFromGeminiAPI(newPrompt);
        let cleanResponse = response.replace(/\`\`\`(html)?/g, '').replace(/\`\`\`/g, '').trim();
        const parser = new DOMParser();
        const aiDoc = parser.parseFromString(cleanResponse, "text/html");
        const bodyContent = aiDoc.body.innerHTML;
        let animatedBodyContent = '';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = bodyContent;
        let lineIndex = 1;
        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            animatedBodyContent += `<div class="line-printing-container"><div class="line-printing-animation" style="--line-index: ${lineIndex};">${node.outerHTML}</div></div>`;
            lineIndex++;
          } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
            animatedBodyContent += `<div class="line-printing-container"><div class="line-printing-animation" style="--line-index: ${lineIndex};"><p>${node.textContent.trim()}</p></div></div>`;
            lineIndex++;
          }
        });
        document.getElementById('documentContainer').innerHTML = `<div class="animate__fadeIn">${animatedBodyContent}</div>`;
        attachOptionEvents();
        scrollToDocument();
      } catch (error) {
        console.error("Error applying edits:", error);
        alert("Failed to apply edits.");
      } finally {
        loaderContainer.style.display = 'none';
        waitingAudio.pause();
      }
    }

    async function fetchFromGeminiAPI(input) {
      const geminiApiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-thinking-exp-01-21:generateContent?key=${GEMINI_API_KEY}`;
      const systemPrompt = `You are Daisy, a very intelligent medical scribe assistant. Generate a full HTML page that follows the sample HTML here https://app.medicalscribe.site/scribe.html.
For any missing or unclear section, fill in with "Not Clear" or "No Data Given" as appropriate.
Do NOT return JSON. Return the full HTML including DOCTYPE, head, and body.
The HTML should be fully self-contained and styled as per the sample template.`;
      const requestBody = {
        "contents": [
          {"role": "user", "parts": [{ "text": systemPrompt + "\n\n" + input}]}
        ],
        "generationConfig": {
          "temperature": 0.7,
          "topK": 64,
          "topP": 0.95,
          "maxOutputTokens": 65536,
          "responseMimeType": "text/plain"
        }
      };
      const response = await fetch(geminiApiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      if (data.candidates && data.candidates.length > 0 &&
          data.candidates[0].content && data.candidates[0].content.parts &&
          data.candidates[0].content.parts.length > 0 && data.candidates[0].content.parts[0].text) {
        const aiResponseContent = data.candidates[0].content.parts[0].text;
        console.log("Raw Gemini AI Response:", aiResponseContent);
        return aiResponseContent;
      } else {
        console.error("Unexpected Gemini API response format:", data);
        throw new Error("Unexpected response format from Gemini API");
      }
    }

    function attachOptionEvents() {
      const saveBtn = document.getElementById('saveDocumentButton');
      const emailBtn = document.getElementById('emailDocumentButton');
      const editBtn = document.getElementById('editDocumentButton');
      if (saveBtn) saveBtn.addEventListener('click', saveDocument);
      if (emailBtn) emailBtn.addEventListener('click', toggleEmailInput);
      if (editBtn) editBtn.addEventListener('click', toggleEditInput);
      const sendEmailBtn = document.getElementById('sendEmailButton');
      if (sendEmailBtn) sendEmailBtn.addEventListener('click', sendEmail);
      const applyEditsBtn = document.getElementById('applyEditsButton');
      if (applyEditsBtn) applyEditsBtn.addEventListener('click', applyEdits);

      document.getElementById('recordEditButton').addEventListener('click', function() {
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
          editMediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          editAudioChunks = [];
          editMediaRecorder.ondataavailable = (event) => editAudioChunks.push(event.data);
          editMediaRecorder.onstop = async () => {
            let editBlob = new Blob(editAudioChunks, { type: 'audio/webm' });
            let formData = new FormData();
            formData.append('audio', editBlob, 'editRecording.webm');
            try {
              const response = await fetch('https://api.deepgram.com/v1/listen?language=en&model=nova-3', {
                method: 'POST',
                headers: { 'Authorization': `Token ${DEEPGRAM_API_KEY}` },
                body: formData
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();
              if (!data.results || !data.results.channels || data.results.channels.length === 0) {
                throw new Error('Invalid response from Deepgram API');
              }
              const editTranscript = data.results.channels[0].alternatives[0].transcript;
              let editTextarea = document.getElementById('editInstructions');
              editTextarea.value += editTranscript;
              document.getElementById('applyEditsButton').disabled = (editTextarea.value.trim() === "");
            } catch (error) {
              console.error('Edit transcription error:', error);
              alert("Failed to transcribe edit instructions: " + error.message);
            }
          };
          editMediaRecorder.start();
          document.getElementById('recordEditButton').innerHTML = '<span class="material-icons">stop</span>';
          document.getElementById('recordEditButton').addEventListener('click', stopEditRecording, { once: true });
        });
      });
    }

    async function stopEditRecording() {
      if (editMediaRecorder && editMediaRecorder.state !== 'inactive') {
        editMediaRecorder.stop();
        document.getElementById('recordEditButton').innerHTML = '<span class="material-icons">mic</span>';
      }
    }

    async function saveDocument() {
      const scribeData = {
        title: document.getElementById('docTitle').value || "No Data Given",
        patientName: document.getElementById('docPatientName').value || "No Data Given",
        assignedMedicalPractitioner: document.getElementById('docAssignedPractitioner').value || "No Data Given",
        conductedOn: document.getElementById('docConductedOn').value || "No Data Given",
        location: document.getElementById('docLocation').value || "No Data Given",
        age: document.getElementById('docAge').value || "No Data Given",
        race: document.getElementById('docRace').value || "No Data Given",
        gender: document.getElementById('docGender').value || "No Data Given",
        chiefComplaint: document.getElementById('docChiefComplaint').value || "No Data Given",
        historyOfIllness: document.getElementById('docHistoryOfIllness').value || "No Data Given",
        pastMedicalHistory: document.getElementById('docPastMedicalHistory').value || "No Data Given",
        familyHistory: document.getElementById('docFamilyHistory').value || "No Data Given",
        socialHistory: document.getElementById('docSocialHistory').value || "No Data Given",
        reviewOfSystems: document.getElementById('docReviewOfSystems').value || "No Data Given",
        height: document.getElementById('docHeight').value || "No Data Given",
        weight: document.getElementById('docWeight').value || "No Data Given",
        bmi: document.getElementById('docBMI').value || "No Data Given",
        temperature: document.getElementById('docTemperature').value || "No Data Given",
        bloodPressure: document.getElementById('docBloodPressure').value || "No Data Given",
        generalAppearance: document.getElementById('docGeneralAppearance').value || "No Data Given",
        eent: document.getElementById('docEENT').value || "No Data Given",
        cardiovascular: document.getElementById('docCardiovascular').value || "No Data Given",
        respiratory: document.getElementById('docRespiratory').value || "No Data Given",
        integument: document.getElementById('docIntegument').value || "No Data Given",
        labResults: document.getElementById('docLabResults').value || "No Data Given",
        generalObservations: document.getElementById('docGeneralObservations').value || "No Data Given",
        differentialDiagnosis: document.getElementById('docDifferentialDiagnosis').value || "No Data Given",
        treatmentPlan: document.getElementById('docTreatmentPlan').value || "No Data Given",
        followUp: document.getElementById('docFollowUp').value || "No Data Given",
        education: document.getElementById('docEducation').value || "No Data Given",
        printedName: document.getElementById('docPrintedName').value || "No Data Given",
        date: document.getElementById('docDate').value || new Date().toLocaleDateString(),
        created_at: firebase.firestore.FieldValue.serverTimestamp()
      };

      try {
        const docRef = await db.collection('scribe_documents').add(scribeData);
        console.log('Document written with ID:', docRef.id);
        alert('Document saved successfully.');
      } catch (error) {
        console.error('Error saving document:', error);
        alert('Failed to save document to Firestore.');
      }
    }

    function toggleEmailInput() {
      const container = document.getElementById('emailInputContainer');
      container.style.display = (container.style.display === 'block') ? 'none' : 'block';
    }

    function sendEmail() {
      const recipient = document.getElementById('recipientEmail').value;
      if (!recipient) {
        alert("Please enter an email address.");
        return;
      }
      const body = encodeURIComponent(documentContainer.innerText);
      window.location.href = `mailto:${recipient}?subject=Generated%20Scribe%20Document&body=${body}`;
    }

    function toggleEditInput() {
      const container = document.getElementById('editInputContainer');
      container.style.display = (container.style.display === 'block') ? 'none' : 'block';
    }

    async function applyEdits() {
      const instructions = document.getElementById('editInstructions').value;
      if (!instructions) {
        alert("Please enter your edit instructions.");
        return;
      }
      loaderContainer.style.display = 'flex';
      waitingAudio.play();
      try {
        const newPrompt = transcriptionText.value + "\nEdits: " + instructions;
        const response = await fetchFromGeminiAPI(newPrompt);
        let cleanResponse = response.replace(/\`\`\`(html)?/g, '').replace(/\`\`\`/g, '').trim();
        const parser = new DOMParser();
        const aiDoc = parser.parseFromString(cleanResponse, "text/html");
        const bodyContent = aiDoc.body.innerHTML;
        let animatedBodyContent = '';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = bodyContent;
        let lineIndex = 1;
        tempDiv.childNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            animatedBodyContent += `<div class="line-printing-container"><div class="line-printing-animation" style="--line-index: ${lineIndex};">${node.outerHTML}</div></div>`;
            lineIndex++;
          } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
            animatedBodyContent += `<div class="line-printing-container"><div class="line-printing-animation" style="--line-index: ${lineIndex};"><p>${node.textContent.trim()}</p></div></div>`;
            lineIndex++;
          }
        });
        document.getElementById('documentContainer').innerHTML = `<div class="animate__fadeIn">${animatedBodyContent}</div>`;
        attachOptionEvents();
        scrollToDocument();
      } catch (error) {
        console.error("Error applying edits:", error);
        alert("Failed to apply edits.");
      } finally {
        loaderContainer.style.display = 'none';
        waitingAudio.pause();
      }
    }

    async function fetchFromGeminiAPI(input) {
      const geminiApiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-thinking-exp-01-21:generateContent?key=${GEMINI_API_KEY}`;
      const systemPrompt = `You are Daisy, a very intelligent medical scribe assistant. Generate a full HTML page that follows the sample HTML here https://app.medicalscribe.site/scribe.html.
For any missing or unclear section, fill in with "Not Clear" or "No Data Given" as appropriate.
Do NOT return JSON. Return the full HTML including DOCTYPE, head, and body.
The HTML should be fully self-contained and styled as per the sample template.`;
      const requestBody = {
        "contents": [
          {"role": "user", "parts": [{ "text": systemPrompt + "\n\n" + input}]}
        ],
        "generationConfig": {
          "temperature": 0.7,
          "topK": 64,
          "topP": 0.95,
          "maxOutputTokens": 65536,
          "responseMimeType": "text/plain"
        }
      };
      const response = await fetch(geminiApiEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      if (data.candidates && data.candidates.length > 0 &&
          data.candidates[0].content && data.candidates[0].content.parts &&
          data.candidates[0].content.parts.length > 0 && data.candidates[0].content.parts[0].text) {
        const aiResponseContent = data.candidates[0].content.parts[0].text;
        console.log("Raw Gemini AI Response:", aiResponseContent);
        return aiResponseContent;
      } else {
        console.error("Unexpected Gemini API response format:", data);
        throw new Error("Unexpected response format from Gemini API");
      }
    }

    function attachOptionEvents() {
      const saveBtn = document.getElementById('saveDocumentButton');
      const emailBtn = document.getElementById('emailDocumentButton');
      const editBtn = document.getElementById('editDocumentButton');
      if (saveBtn) saveBtn.addEventListener('click', saveDocument);
      if (emailBtn) emailBtn.addEventListener('click', toggleEmailInput);
      if (editBtn) editBtn.addEventListener('click', toggleEditInput);
      const sendEmailBtn = document.getElementById('sendEmailButton');
      if (sendEmailBtn) sendEmailBtn.addEventListener('click', sendEmail);
      const applyEditsBtn = document.getElementById('applyEditsButton');
      if (applyEditsBtn) applyEditsBtn.addEventListener('click', applyEdits);

      document.getElementById('recordEditButton').addEventListener('click', function() {
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
          editMediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
          editAudioChunks = [];
          editMediaRecorder.ondataavailable = (event) => editAudioChunks.push(event.data);
          editMediaRecorder.onstop = async () => {
            let editBlob = new Blob(editAudioChunks, { type: 'audio/webm' });
            let formData = new FormData();
            formData.append('audio', editBlob, 'editRecording.webm');
            try {
              const response = await fetch('https://api.deepgram.com/v1/listen?language=en&model=nova-3', {
                method: 'POST',
                headers: { 'Authorization': `Token ${DEEPGRAM_API_KEY}` },
                body: formData
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();
              if (!data.results || !data.results.channels || data.results.channels.length === 0) {
                throw new Error('Invalid response from Deepgram API');
              }
              const editTranscript = data.results.channels[0].alternatives[0].transcript;
              let editTextarea = document.getElementById('editInstructions');
              editTextarea.value += editTranscript;
              document.getElementById('applyEditsButton').disabled = (editTextarea.value.trim() === "");
            } catch (error) {
              console.error('Edit transcription error:', error);
              alert("Failed to transcribe edit instructions: " + error.message);
            }
          };
          editMediaRecorder.start();
          document.getElementById('recordEditButton').innerHTML = '<span class="material-icons">stop</span>';
          document.getElementById('recordEditButton').addEventListener('click', stopEditRecording, { once: true });
        });
      });
    }

    async function stopEditRecording() {
      if (editMediaRecorder && editMediaRecorder.state !== 'inactive') {
        editMediaRecorder.stop();
        document.getElementById('recordEditButton').innerHTML = '<span class="material-icons">mic</span>';
      }
    }

    async function saveToFirestore() {
      alert("Use the 'Save' option in the generated document instead.");
    }

    function scrollToDocument() {
      setTimeout(() => {
        document.getElementById('documentContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 300);
    }
  </script>
</body>
    </html>
